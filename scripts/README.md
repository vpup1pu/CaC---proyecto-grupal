Agregamos este archivo para explicar nuestros scripts.
1. *products.js* es el corazón del proyecto. Encontrará una clase constructora de productos, y cuatro arrays. Cada array será utilizado en los scripts correspondientes. Por ejemplo, el array *stuffNiño* es utilizado en el script *niño.js*. 
> Los arrays contienen objetos creados a partir de la clase Product, en cuanto a sus propiedades cuenta con: 
> * *frontImage* y *sideImage* reciben las imágenes que se encuentran en la carpeta img.
> * *name* es el nombre del producto
> * *type* funciona para filtrar los productos en los aside y dropdown. 
> * *price* recibe el precio del producto. Es importante que sea tipo número sin comas ni puntos.
> * *variations* es un array de objetos, donde cada objeto representa una variación del producto. A su vez, sus propiedades son: *size* (tamaño), *color* y *availability* (si se encuentra disponible o fuera de stock).
> * *discount* es una propiedad opcional. Si un producto tiene type 'Descuentos', entonces se le ingresa un discount que debe ser tipo número.
> * Por último, cuenta con un método **sale()** que devuelve un booleano si el producto tiene type 'Descuentos'.

<br>

2. Los archivos js nombrados *app.js, hombre.js, mujer.js* y *niño.js* son los que serán utilizados por Webpack para crear los bundle.js que se utilizarán en cada HTML correspondiente. Importan un array de objetos desde *products.js* y dos funciones desde *function.js*. Si bien cuentan con modificaciones según su finalidad, en general almacenan en constantes un div, que actua de contenedor para los productos, y los botones del aside y dropdown; para luego ejecutar las funciones importadas. La diferencia entre *app.js* y el resto es que va a utilizar un array llamado **stock** cuyos elementos son los otros tres array de objetos; y antes de ejecutar la función importada, filtra **stock** por el *type* de cada objeto. Luego los añade a un nuevo array llamado **arrayDescuentos**, de manera tal que terminará renderizando en el div solamente los objetos cuyo type sean 'Descuentos'.
3. *formulario.js* es un script solo utilizado para *tab-contacto.html*. Provee la validación para el formulario de contactos, cuando el usuario se equivoca muestra un mensaje de error. Agrega un contador para indicarle al usuario la cantidad de caracteres que tiene disponible para dejar su mensaje. Muestra un mensaje de envio exitoso cuando cuando el usuario completa correctamente el formulario y finalmente limpia cada input una vez que el envío es correcto.
4. Por último, tenemos *functions.js*. Es la más extensa de navegar, así que incluiré un resumen de cada función:
> - **displayContainer(productsArray, currentContainer)** recibe un array de objetos y un contenedor por parámetro. Este contenedor es el div que tiene cada html donde se espera que cada producto sea renderizado. Por cada producto del array que le llegue por parámetro, crea un elemento div llamado *shoeDiv* y se lo apendea al contenedor que le llega por parámetro. *shoeDiv* a su vez tiene dos hijos, uno donde se encuentran las imágenes (*imageContainer*) y otro donde se encuentra la información del producto (*lilDisplay*), los cuales son nombre y precio. Toda esta información la encuentra en las propiedades de cada objeto. Luego, ejecuta una función llamada **onSale(product, priceSpan, discount, containerText, containerImg)** (es una función cortita, como se encuentra en un forEach, recibe de cada producto el resultado del método **sale()**, si es verdadero, le agrega un ribbon que muestra el descuento que posee el producto, tacha el precio original y agrega al lado el nuevo precio con el descuento aplicado. Este descuento es la propiedad discount del objeto) y tiene un eventListener, el cual se queda atento a cada vez que tocamos el producto. Si lo tocamos, almacena en nuevas variables let clones de *imageContainer* y de *priceCont* (el precio que se renderiza en *lilDisplay*) para utilizarlos en una función llamada **Display(imageContainer, name, price, currentContainer, array1)**.
*¿Por qué clones?* Quería reutilizar código sin que afecte a los nodos originales. La función **Display()** tiene ajustes tanto en el CSS como en el apendeo de estos nodos dentro de la función, por lo tanto, si utilizaba solamente *imageContainer*, cuando se ejecutara la función **Display()**, este nodo cambiaría su herencia de lugar, modificando la función **displayContainer()**.
> - **Display(imageContainer, name, price, currentContainer, array1)** es la función que crea un dialog en donde se renderiza la información del producto. Esta función existe porque no pudimos ejecutar nuestra idea original. Cuando pensamos el proyecto, queríamos crear un único html que renderice la información de cada producto seleccionado, y contenga la opción de elegir talle, color, agregar al carrito. Probamos muchas ideas pero no encontramos la manera de hacerlo desde el front, por lo que, luego de realizar una consulta con nuestro profesor, decidimos dejarlo para el back, y crear momentáneamente esta función. Crea un dialog, en él renderiza lo que recibe por parámetro (el clon de imageContainer, el nombre del producto y el clon de priceCont), lo apendea al div que le llega por parámetro *currentContainer*, y crea un botón para cerrar el dialog, que al tocarlo, limpia cada opción seleccionada y remueve al dialog que había sido previamente apendiado al div *currentContainer*. Esto se debe a que más adelante, en esta función se crean radiobuttons que contienen un id, por lo que, si el dialog previamente creado continuara como hijo del *currentContainer*, los nuevos id de los radiobuttons serían los mismos y entrarían en conflicto.
Esta función tambien crea botones que simulan agregar o quitar una cantidad del producto al carrito. Por el momento, solo es simulación. De hecho, al tocar 'Agregar al carrito', todos los inputs se limpian. Pero planeamos reincorporar estos botones y expander su funcionalidad en el back.
En esta función también se ejecuta la función **variations(array, prop1, prop2, currentContainer, imgContainer)**, que merece una descripción en otro asterisco, pero en esencia, muestra las variaciones de talle y color de cada producto, y al seleccionarlas devuelve si está fuera de stock o no. Vale notar que el array1 que nos llega por parámetro en **Display()** es utilizado como argumento en **variations()**.
> - **variations(array, prop1, prop2, currentContainer, imgContainer)** es una función que crea radio buttons por cada opción que se encuentra en el array variations de cada objeto. Entonces, el parámetro *array* recibe el array de objetos *variations* que recibe de **Display()**, el cual, a su vez, es una propiedad de cada producto. Entonces, la función **variatios()** comienza ejecutando otra función, **options(array, property)**, que lo que hace es crear un nuevo array llamado newArr, y le agrega los elementos que contengan valores diferentes de la propiedad que le llega por argumento. Entonces, al comienzo, crea un array para los diferentes talles del producto. Luego, por cada talle, crea un radio button que se identifica con cada talle. Es decir, si **options()** devuelve un array como por ej, [8, 9], la primera parte de la función **variations()** crea un radio button por cada elemento de ese array. La manera en que está hecho es para poder darle un CSS personalizado. Luego, le apendea estos botones al div que le llega por parámetro, *currentContainer*. En la segunda parte de la función **variations()**, realiza lo mismo pero con la propiedad *color* y se lo apendea al div *currentContainer*. En la parte final de esta función, guarda en una constante los radiobuttons elegidos: de talle y color, y agrega un eventListener que se queda atento a los cambios. Si surge un cambio, ejecuta la función **checkAvailability(array, imgCont)**, cuyos argumentos son los que **variations()** tiene por parámetro.
> - **checkAvailability(array, imgCont)** es la función que revisa la propiedad *availability* del array *variations* de cada producto. Comienza guardando en constantes las opciones seleccionadas en la función **selectedChoice(prop)**, que lo que hace es eso, devolver el valor seleccionado de un radio button. Si no hay nada seleccionado, devuelve null. Volviendo a **checkAvailability()**, inicializa la variable let ribbonDiv, si no la encuentra, la crea. Es un ribbon que se posiciona por encima de las imágenes y dice 'Sin Stock'. Entonces, una vez que ambas opciones de talle y color tienen un valor que no sea 'null', compara en cada objeto del array *variations* hasta encontrar el nodo que coincida con las opciones seleccionadas. Luego, chequea *availability*, si es 'fuera de stock', hace que el ribbon inicializado previamente sea visible, si no, lo deja invisible.
> - Por último, nos queda la otra función que se exporta, **filteredBtn(arrayBtn, typeVariation, arrayCurrent, currentContainer)**. El tema es que los botones del aside **Categorias** y los del dropdown que se encuentran en el html tienen la misma clase. Entonces, en los otros scripts, los seleccionamos en un querySelectorAll que ingresa en el parámetro *arrayBtn* y le pedimos que por cada botón de ese array, ejecuten un eventListener. Entonces, cada vez que se clickea alguno de ellos, pedimos que guarde en una constante el resultado de la función **filter(typeVariation, currentContainer)**, que lo que hace es mostrar en el div que le llega por parámetro solamente los productos que tengan el type ingresado por parámetro. De esta manera, si se elige el botón 'Urbanos', en el div correspondiente se mostrarán sólo los productos cuyo type sean 'Urbanos'. Al final de la función **filteredBtn()** vuelve a ejecutar **displayContainer()**, para que 'actualice' lo que está ocurriendo. Si volvemos a ver **displayContainer()**, la primera linea limpia el contenido del div que le llega por parámetro. Esto es para que siempre se pueda retroceder al momento inicial: ver todos los productos cargados en el contenedor correcto.
>> Esta función no funciona de un html a otro. Es decir, si estoy en tab-niños.html y elijo desde el dropdown de mujer algo, la función no se ejecuta. No sabemos cómo hacerlo, por eso planeamos expandirla durante la etapa del back. Sin embargo, si se elige algo desde el dropdown de niños o desde el aside **Categorias**, la función se ejecuta sin problemas.